#include "image.h"
#include <node_buffer.h>

#include <string>
#include <string.h>

using namespace std;
using namespace node;
using namespace v8;

FIBITMAP*
CreateBitmapFromPixels(int width, int height, int bitsPerPixel, void* data=NULL)
{
    FIBITMAP* bmp;
    BYTE* bits;
    int channels = (bitsPerPixel / 8);
    
    if ((bmp = FreeImage_Allocate(width, height, bitsPerPixel)) == NULL)
        return NULL;
    
    
    if ((bits = FreeImage_GetBits(bmp)) == NULL)
    {
        FreeImage_Unload(bmp);
        return NULL;
    }
    
    if (data != NULL)
        memcpy(bits, data, (width * height) * channels);
    
    return bmp;
}

string
EscapeString(const char* data, int len)
{
    int i;
    string buf;

    for (i=0 ; i < len ; i++) {
        switch(data[i]) {
            case '"':
                buf.append("\\\"");
                break;
            default:
                buf.append((data+i),1);
                break;
        }
    }
    return buf;
}

Persistent<FunctionTemplate> image::constructor_template;

image::image(Handle<Object> wrapper) :
        dib(NULL) {
}

image::~image() {
    if (dib != NULL)
        FreeImage_Unload(dib);
}

void
image::init(Handle<Object> target) {
    HandleScope scope;

    Local<FunctionTemplate> t = FunctionTemplate::New(image::New);

    constructor_template = Persistent<FunctionTemplate>::New(t);

    constructor_template->InstanceTemplate()->SetInternalFieldCount(1);

    constructor_template->SetClassName(String::New("image"));

    NODE_SET_PROTOTYPE_METHOD(constructor_template, "read", read);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "write", write);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "dispose", dispose);

    NODE_SET_PROTOTYPE_METHOD(constructor_template, "flip", flip);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "rotate", rotate);        
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "gray", grayscale);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "scale", scale);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "crop", crop);
    NODE_SET_PROTOTYPE_METHOD(constructor_template, "alpha", alpha);

    NODE_SET_PROTOTYPE_METHOD(constructor_template, "metadata", metadata);
    
    target->Set(String::New("image"), constructor_template->GetFunction());
}

Handle<Value>
image::New(const Arguments& args) {
    HandleScope scope;
    image* img = new image(args.This());
    img->Wrap(args.This());
    return scope.Close(args.This());
}


image*
image::New(FIBITMAP* dib) {
    HandleScope scope;

    Local<Value> arg = Integer::NewFromUnsigned(0);
    Local<Object> obj = constructor_template->GetFunction()->NewInstance(1, &arg);

    image* img = ObjectWrap::Unwrap<image>(obj);
    
    img->dib = dib;

    obj->Set(String::New("width"), Integer::NewFromUnsigned(FreeImage_GetWidth(img->dib)));
    obj->Set(String::New("height"), Integer::NewFromUnsigned(FreeImage_GetHeight(img->dib)));
    obj->Set(String::New("bpp"), Integer::NewFromUnsigned(FreeImage_GetBPP(img->dib)));
    obj->Set(String::New("pitch"), Integer::NewFromUnsigned(FreeImage_GetPitch(img->dib)));
    obj->Set(String::New("type"), Integer::New(FreeImage_GetImageType(img->dib)));
                                               
    return img;
    
}

Handle<Value>
image::read(const Arguments& args) {
    HandleScope scope;
    Local<Object> obj = args.This();
    image* img = ObjectWrap::Unwrap<image>(obj);

    if (args.Length() < 1) {
        fprintf(stderr, "image::read() needs atleast 1 argument\n");
        return scope.Close(Boolean::New(false));
    }
    
    String::Utf8Value path(args[0]);

    FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;
    
    FIBITMAP* tmp;

    fif = FreeImage_GetFileType(*path);

    if (fif == FIF_UNKNOWN)
        fif = FreeImage_GetFIFFromFilename(*path);

    if (fif == FIF_UNKNOWN) {
        fprintf(stderr, "image::read() unable to determine file format (%s)\n", *path);
        return scope.Close(Boolean::New(false));
    }

    if (!FreeImage_FIFSupportsReading(fif)) {
        fprintf(stderr, "image::read() unsupported file format (%s)\n", *path);
        return scope.Close(Boolean::New(false));
    }

    tmp = FreeImage_Load(fif, *path);

    if (tmp == NULL) {
        fprintf(stderr, "image::read() read failed (%s)\n", *path);
        return scope.Close(Boolean::New(false));
    }

    if (img->dib != NULL)
        FreeImage_Unload(img->dib);

    img->dib = tmp;

    obj->Set(String::New("width"), Integer::NewFromUnsigned(FreeImage_GetWidth(img->dib)));
    obj->Set(String::New("height"), Integer::NewFromUnsigned(FreeImage_GetHeight(img->dib)));
    obj->Set(String::New("bpp"), Integer::NewFromUnsigned(FreeImage_GetBPP(img->dib)));
    obj->Set(String::New("pitch"), Integer::NewFromUnsigned(FreeImage_GetPitch(img->dib)));
    obj->Set(String::New("type"), Integer::New(FreeImage_GetImageType(img->dib)));
    obj->Set(String::New("format"), Integer::New(fif));
    
    return scope.Close(Boolean::New(true));
}

Handle<Value>
image::write(const Arguments& args) {
    HandleScope scope;

    image* img = ObjectWrap::Unwrap<image>(args.This());

    if (args.Length() < 1) {
        fprintf(stderr, "image::write() needs atleast 1 argument\n");
        return scope.Close(Boolean::New(false));
    }

    String::Utf8Value path(args[0]);

    FREE_IMAGE_FORMAT fif = FreeImage_GetFIFFromFilename(*path);

    if (fif == FIF_UNKNOWN) {
        fif = FIF_PNG;
    }

    if (args.Length() > 1) {
        fif = (FREE_IMAGE_FORMAT)args[1]->Int32Value();
        if (fif < 0 || fif > FIF_JP2) {
            fprintf(stderr,"image::write() specified format is unknown!\n");
            return scope.Close(Boolean::New(false));
        }
    }
    
    return scope.Close(Boolean::New((FreeImage_Save(fif, img->dib, *path) == TRUE)));
}

Handle<Value>
image::dispose(const Arguments& args) {
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());

    if (img->dib != NULL)
        FreeImage_Unload(img->dib);
    img->dib = NULL;
    return Undefined();
}

Handle<Value>
image::flip(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

    unsigned int bpp = FreeImage_GetBPP(img->dib);

    unsigned int step = (bpp/8);
    
    unsigned int width  = FreeImage_GetWidth(img->dib);
    unsigned int height = FreeImage_GetHeight(img->dib);
    unsigned int spitch  = FreeImage_GetPitch(img->dib);
	
	tmp = CreateBitmapFromPixels(width, height, bpp);

    if (NULL == tmp) {
        fprintf(stderr, "image::flip(), out of memory\n");
        return Null();
    }
    
    BYTE* src_bits  = (BYTE*) FreeImage_GetBits(img->dib);
    BYTE* dst_bits  = (BYTE*) FreeImage_GetBits(tmp);
        
	unsigned int dpitch = FreeImage_GetPitch(tmp);
    
    for (unsigned int y=0 ; y < height ; y++)
    {
        BYTE* src_pixels = (BYTE*)src_bits;
        BYTE* dst_pixels = (BYTE*)dst_bits;
        
        for (unsigned int x=0 ; x < width ; x++)
        {
            
            dst_pixels = src_pixels;
            
            src_pixels += step;
            dst_pixels -= step;
        }
        
        src_bits += spitch;
        dst_bits += dpitch;
    }
    
    return scope.Close(image::New(tmp)->handle_);
}

Handle<Value>
image::rotate(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

    double angle = args[0]->NumberValue();
    
#if (FREEIMAGE_MAJOR_VERSION == 3 && FREEIMAGE_MINOR_VERSION >= 15)
    tmp = FreeImage_Rotate(img->dib, angle);
#else
    tmp = FreeImage_RotateClassic(img->dib, angle);
#endif

    if (NULL == tmp) {
        fprintf(stderr, "image::rotate() failed\n");
        return Null();
    }

    return scope.Close(image::New(tmp)->handle_);

}

Handle<Value>
image::grayscale(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

    unsigned int bpp = FreeImage_GetBPP(img->dib);
    
	if (bpp < 24) {
	    fprintf(stderr, "image::grayscale(), bad depth\n");
        return Null();
	}

    unsigned int width  = FreeImage_GetWidth(img->dib);
    unsigned int height = FreeImage_GetHeight(img->dib);
    unsigned int spitch  = FreeImage_GetPitch(img->dib);
	
	tmp = CreateBitmapFromPixels(width, height, 8);

    if (NULL == tmp) {
        fprintf(stderr, "image::grayscale(), out of memory\n");
        return Null();
    }
    
    BYTE* src_bits  = (BYTE*) FreeImage_GetBits(img->dib);
    BYTE* dst_bits  = (BYTE*) FreeImage_GetBits(tmp);
        
	unsigned int dpitch = FreeImage_GetPitch(tmp);
    
	float r,g,b;

    for (unsigned int y=0 ; y < height ; y++)
    {
        BYTE* src_pixels = (BYTE*)src_bits;
        BYTE* dst_pixels = (BYTE*)dst_bits;
        
        for (unsigned int x=0 ; x < width ; x++)
        {
            r = (float)src_pixels[FI_RGBA_RED];
            g = (float)src_pixels[FI_RGBA_GREEN];
            b = (float)src_pixels[FI_RGBA_BLUE];
            
            dst_pixels[0] = ((0.299*r) + (0.587*g) + (0.114*b));
            
            src_pixels += (bpp == 32) ? 4 : 3;
            dst_pixels++;
        }
        
        src_bits += spitch;
        dst_bits += dpitch;
    }
    
    return scope.Close(image::New(tmp)->handle_);
}

Handle<Value>
image::scale(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

    FREE_IMAGE_FILTER filter = FILTER_BILINEAR;
    
    unsigned int w=0,h=0;

    if (args.Length() < 2) {
        fprintf(stderr, "image::scale(w,h) invalid argument\n");
        return Null();
    }
    
    w = args[0]->Int32Value();
    h = args[1]->Int32Value();

    if (args.Length() > 2) {
        filter = (FREE_IMAGE_FILTER)args[2]->Int32Value();
        if (filter < 0 || filter > FILTER_LANCZOS3) {
            fprintf(stderr,"image::scale(), invalid filter value, reverting to default\n");
            filter = FILTER_BILINEAR;
        }
    }
    
    tmp = FreeImage_Rescale(img->dib, w, h, filter);

    if (NULL == tmp) {
        fprintf(stderr, "image::scale() failed\n");
        return Null();
    }

    return scope.Close(image::New(tmp)->handle_);
}

Handle<Value>
image::crop(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

    unsigned int i=0,x=0,y=0,w=0,h=0;

    if (args.Length() < 2) {
        fprintf(stderr, "image::crop(x,y,w,h) invalid argument\n");
        return Null();
    }
    
    if (args.Length() > 2) {
        x = args[0]->Int32Value();
        y = args[1]->Int32Value();
        i=2;
    }
    
    w = args[i++]->Int32Value();
    h = args[i++]->Int32Value();

    tmp = FreeImage_Copy(img->dib, x, y, x+w, y+h);

    if (NULL == tmp) {
        fprintf(stderr, "image:crop() failed\n");
        return Null();
    }

    return scope.Close(image::New(tmp)->handle_);
    
}

Handle<Value>
image::alpha(const Arguments& args) {
    FIBITMAP* tmp;
    HandleScope scope;
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();
    
    unsigned int bpp = FreeImage_GetBPP(img->dib);
    
	if (bpp != 32) {
	    fprintf(stderr, "image::alpha(), 32 bit image is required\n");
        return Null();
	}

    unsigned int width  = FreeImage_GetWidth(img->dib);
    unsigned int height = FreeImage_GetHeight(img->dib);
    unsigned int spitch  = FreeImage_GetPitch(img->dib);
	
	tmp = CreateBitmapFromPixels(width, height, 24);

    if (NULL == tmp) {
        fprintf(stderr, "image::alpha(), out of memory\n");
        return Null();
    }
    
    BYTE* src_bits  = (BYTE*) FreeImage_GetBits(img->dib);
    BYTE* dst_bits  = (BYTE*) FreeImage_GetBits(tmp);
        
	unsigned int dpitch = FreeImage_GetPitch(tmp);
    
    for (unsigned int y=0 ; y < height ; y++)
    {
        BYTE* src_pixels = (BYTE*)src_bits;
        BYTE* dst_pixels = (BYTE*)dst_bits;
        
        for (unsigned int x=0 ; x < width ; x++)
        {
            dst_pixels[FI_RGBA_BLUE] = 
                dst_pixels[FI_RGBA_GREEN] = 
                dst_pixels[FI_RGBA_RED] = src_pixels[FI_RGBA_ALPHA];
            
            src_pixels += 4;
            dst_pixels += 3;
        }
        
        src_bits += spitch;
        dst_bits += dpitch;
    }
    
    return scope.Close(image::New(tmp)->handle_);
    
}

Handle<Value>
image::metadata(const Arguments& args) {
    string             js;
    string             tmp;
    FIMETADATA*        md    = NULL;
    FITAG*             tag   = NULL;
    FREE_IMAGE_MDMODEL model = FIMD_NODATA;
    FREE_IMAGE_MDTYPE  type  = type;
    unsigned int       len;
    const char*        key;
    const void*        value;
    char               buf[1024];
    BOOL               keepGoing = TRUE;
    HandleScope        scope;
    
    image* img = ObjectWrap::Unwrap<image>(args.This());
    if (img->dib == NULL)
        return Null();

        
    if (args.Length() > 0) {
        model = (FREE_IMAGE_MDMODEL)args[0]->Int32Value();
        if (model < 0 || model > FIMD_CUSTOM) {
            fprintf(stderr, "image::metadata() unknown model\n");
            return Null();
        }
    }

    len = FreeImage_GetMetadataCount(model, img->dib);

    if (len == 0) {
        return Null();
    }
    
    md = FreeImage_FindFirstMetadata(model, img->dib, &tag);

    if (NULL == md) {
        fprintf(stderr, "image::metadata() open failed\n");
        return Null();
    }

    js.append("{");
    
    do {

        key   = FreeImage_GetTagKey(tag);
        len   = FreeImage_GetTagLength(tag);
        type  = FreeImage_GetTagType(tag);
        value = FreeImage_GetTagValue(tag);

        js.append("\"");
        js.append(key);
        js.append("\":");

        switch (type) {
            case FIDT_NOTYPE:
                js.append("null");
                break;
            case FIDT_BYTE:
                sprintf(buf, "%u", *((const unsigned char*)value));
                js.append(buf);
                break;
            case FIDT_ASCII:
                js.append("\"");
                js.append(EscapeString((const char*)value, len).c_str());
                js.append("\"");
                break;
            case FIDT_SHORT:
                sprintf(buf, "%hu", *((const unsigned short*)value));
                js.append(buf);
                break;
            case FIDT_LONG:
                sprintf(buf, "%lu", *((const unsigned long*)value));
                js.append(buf);
                break;
            case FIDT_RATIONAL:
                sprintf(buf, "\"%lu/%lu\"", *((const unsigned long*)value), *((const unsigned long*)value+sizeof(long)));
                js.append(buf);
                break;
            case FIDT_SBYTE:
                sprintf(buf, "%hhd", *((const char*)value));
                js.append(buf);
                break;
            case FIDT_UNDEFINED:
                js.append("null");
                break;
            case FIDT_SSHORT:
                sprintf(buf, "%hd", *((const short*)value));
                js.append(buf);
                break;
            case FIDT_SLONG:
                sprintf(buf, "%ld", *((const long*)value));
                js.append(buf);
                break;
            case FIDT_SRATIONAL:
                sprintf(buf, "\"%ld/%ld\"", *((const unsigned long*)value), *((const unsigned long*)value+sizeof(long)));
                js.append("null");
                break;
            case FIDT_FLOAT:
                sprintf(buf, "%.05f", *((const float*)value));
                js.append(buf);
                break;
            case FIDT_DOUBLE:
                sprintf(buf, "%.10f", *((const double*)value));
                js.append(buf);
                break;
            case FIDT_IFD:
                sprintf(buf, "%u", *((const int*)value));
                js.append(buf);
                break;
            case FIDT_PALETTE:
                sprintf(buf, "%u", *((const int*)value));
                js.append(buf);
                break;

#if (FREEIMAGE_MAJOR_VERSION == 3 && FREEIMAGE_MINOR_VERSION >= 15)
            case FIDT_LONG8:
                sprintf(buf, "%llu", *((const unsigned long long*)value));
                js.append(buf);
                break;
            case FIDT_SLONG8:
                sprintf(buf, "%lld", *((const long long*)value));
                js.append(buf);
                break;
            case FIDT_IFD8:
                sprintf(buf, "%llu", *((const unsigned long long*)value));
                js.append(buf);
                break;
#endif
            default:
                js.append("null");
                break;
                
        }
        
        keepGoing = FreeImage_FindNextMetadata(md, &tag);

        if (keepGoing)
            js.append(",");
        
    } while (keepGoing);

    js.append("}");

    FreeImage_FindCloseMetadata(md);

    key = js.data();
    len = js.length();
    
    return scope.Close(image::parse(key, len));
    
}

Handle<Value>
image::parse(const char* buffer, int length) {
    HandleScope scope;

    Handle<Context> context = Context::GetCurrent();
    Handle<Object>  global = context->Global();

    Handle<Object> JSON = global->Get(String::New("JSON"))->ToObject();
    
    Handle<Function> JSON_parse = Handle<Function>::Cast(JSON->Get(String::New("parse")));

    Handle<Value> jsonString = String::New(buffer, length);
    
    return scope.Close(JSON_parse->Call(JSON, 1, &jsonString));
}

extern "C" {
    static void init(Handle<Object> target) {
        image::init(target);
    }
    NODE_MODULE(im, init);
}       
